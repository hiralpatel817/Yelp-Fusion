package com.currymonster.fusion.presentation.baseimport android.os.Bundleimport android.view.MenuItemimport android.view.Viewimport androidx.appcompat.app.AppCompatActivityimport androidx.appcompat.widget.Toolbarimport androidx.core.content.ContextCompatimport androidx.navigation.NavControllerimport androidx.navigation.NavDestinationimport androidx.navigation.findNavControllerimport com.afollestad.materialdialogs.MaterialDialogimport com.afollestad.materialdialogs.StackingBehaviorimport com.currymonster.fusion.Rimport com.currymonster.fusion.common.DialogEventimport com.currymonster.fusion.common.LifeCycleAutoDisposerimport com.currymonster.fusion.common.ProgressStateimport com.currymonster.fusion.common.ToolbarTypeimport com.currymonster.fusion.extensions.hideKeyboardimport com.currymonster.fusion.presentation.base.viewmodelfactory.ViewModelFactoryimport com.google.android.material.snackbar.Snackbarimport io.reactivex.disposables.Disposableimport kotlinx.android.synthetic.main.activity_home.*import javax.inject.Injectabstract class BaseActivity : AppCompatActivity(), NavController.OnDestinationChangedListener {    @Inject    lateinit var factory: ViewModelFactory    protected open val toolbar: Toolbar? = null    private val navController: NavController?        get() = try {            findNavController(R.id.navHostFragment)        } catch (e: Throwable) {            null        }    private val autoDisposer =        LifeCycleAutoDisposer()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        autoDisposer.attach(this)        // Restore the view model state if possible here        savedInstanceState?.let {            restoreViewModelState(it)        }    }    override fun onPostCreate(savedInstanceState: Bundle?) {        super.onPostCreate(savedInstanceState)        navController?.let {            it.addOnDestinationChangedListener(this)        }    }    override fun onDestroy() {        navController?.let {            it.removeOnDestinationChangedListener(this)        }        autoDisposer.detach(this)        super.onDestroy()    }    override fun onOptionsItemSelected(item: MenuItem): Boolean =        when (item.itemId) {            android.R.id.home -> {                currentFocus?.hideKeyboard()                onBackPressed()                true            }            else -> {                super.onOptionsItemSelected(item)            }        }    override fun onBackPressed() {        // If the activity doesn't have a nav controller, do the usual thing        if (navController == null) return super.onBackPressed()        navController?.let {            if (!it.popBackStack()) super.onBackPressed()        }    }    fun <T : Disposable> autoDispose(disposable: T): T =        autoDisposer.autoDispose(disposable)    open fun restoreViewModelState(savedInstanceState: Bundle) {    }    override fun onSaveInstanceState(outState: Bundle) {        saveViewModelState(outState)        super.onSaveInstanceState(outState)    }    open fun saveViewModelState(outState: Bundle) {    }    override fun onDestinationChanged(        controller: NavController,        destination: NavDestination,        arguments: Bundle?    ) {        var defaultToolbarType = true        destination.arguments.entries.forEach {            when (it.key) {                "toolbarType" -> {                    defaultToolbarType = false                    supportActionBar?.apply {                        elevation = resources.getDimension(R.dimen.default_tool_elevation)                        when (it.value.defaultValue as ToolbarType) {                            ToolbarType.CLOSE -> {                                toolbar?.visibility = View.VISIBLE                                setHomeAsUpIndicator(R.drawable.ic_close_white)                                setDisplayUseLogoEnabled(false)                                setDisplayShowTitleEnabled(true)                                setDisplayHomeAsUpEnabled(true)                                title = destination.label                            }                            ToolbarType.MODAL -> {                                toolbar?.visibility = View.VISIBLE                                setHomeAsUpIndicator(R.drawable.ic_close_primary)                                setDisplayUseLogoEnabled(false)                                setDisplayShowTitleEnabled(true)                                setDisplayHomeAsUpEnabled(true)                                title = destination.label                                toolbar?.setBackgroundColor(                                    ContextCompat.getColor(                                        this@BaseActivity,                                        R.color.background                                    )                                )                            }                            ToolbarType.UP -> {                                toolbar?.visibility = View.VISIBLE                                setDisplayUseLogoEnabled(false)                                setDisplayShowTitleEnabled(true)                                setDisplayHomeAsUpEnabled(true)                                title = destination.label                            }                            ToolbarType.LOGO -> {                                toolbar?.visibility = View.VISIBLE                                setDisplayUseLogoEnabled(false)                                setDisplayShowTitleEnabled(true)                                setDisplayHomeAsUpEnabled(false)                                title = ""                            }                            ToolbarType.HOME -> {                                toolbar?.visibility = View.VISIBLE                                setDisplayUseLogoEnabled(false)                                setDisplayShowTitleEnabled(true)                                setDisplayHomeAsUpEnabled(false)                                title = destination.label                            }                            ToolbarType.NONE -> {                                toolbar?.visibility = View.GONE                            }                        }                    }                }            }        }        if (defaultToolbarType) {            supportActionBar?.apply {                elevation = resources.getDimension(R.dimen.default_tool_elevation)                toolbar?.visibility = View.VISIBLE                setDisplayUseLogoEnabled(false)                setDisplayShowTitleEnabled(true)                setDisplayHomeAsUpEnabled(true)                title = destination.label            }        }    }    fun onCloseActivity() {        finish()    }    fun onProgressStateChanged(progressState: ProgressState) {        progressView?.setState(progressState)    }    fun onDialogStateChanged(dialogState: DialogEvent) {        dialogState.getCallbacks().onDisplay()        val dialog: MaterialDialog = MaterialDialog.Builder(this)            .title(dialogState.getTitle())            .content(dialogState.getMessage())            .titleColorRes(R.color.textColorHeader)            .contentColorRes(R.color.textColorContent)            .positiveColorRes(R.color.textColorPositive)            .negativeColorRes(R.color.textColorNegative)            .neutralColorRes(R.color.textColorNeutral)            .neutralText(dialogState.getButtonNeutralText())            .negativeText(dialogState.getButtonNegativeText())            .positiveText(dialogState.getButtonPositiveText())            .stackingBehavior(if (dialogState.getVerticalButton()) StackingBehavior.ALWAYS else StackingBehavior.ADAPTIVE)            .onNeutral { _, _ -> dialogState.getCallbacks().onButtonNeutral() }            .onNegative { _, _ -> dialogState.getCallbacks().onButtonNegative() }            .onPositive { _, _ -> dialogState.getCallbacks().onButtonPositive() }            .autoDismiss(true)            .canceledOnTouchOutside(true)            .dismissListener { dialogState.getCallbacks().onDismiss() }            .cancelListener { dialogState.getCallbacks().onCancel() }            .show()        if (dialogState.getTitle().isEmpty()) {            dialog.titleView?.visibility = View.GONE        }        if (dialogState.getMessage().isEmpty()) {            dialog.contentView?.visibility = View.GONE        }    }    fun showSnackbar(message: String) {        val view = findViewById(R.id.container) as? View        view?.also {            Snackbar.make(view, message, Snackbar.LENGTH_LONG).show()        }    }}